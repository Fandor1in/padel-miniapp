"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const betterPromises = require("better-promises");
const fpTs = require("fp-ts");
const parsing = require("./parsing-4VnIGv0b.cjs");
const toolkit = require("@tma.js/toolkit");
const createHmac = async (data, key) => {
  const encoder = new TextEncoder();
  return crypto.subtle.sign(
    "HMAC",
    await crypto.subtle.importKey(
      "raw",
      typeof key === "string" ? encoder.encode(key) : key,
      { name: "HMAC", hash: "SHA-256" },
      false,
      ["sign", "verify"]
    ),
    typeof data === "string" ? encoder.encode(data) : data
  );
};
function hashToken(token) {
  return parsing.hashToken(token, createHmac);
}
function isValidFp(value, token, options) {
  return fpTs.function.pipe(
    validateFp(value, token, options),
    fpTs.taskEither.match(
      (error) => {
        return [
          parsing.AuthDateInvalidError,
          parsing.ExpiredError,
          parsing.SignatureInvalidError,
          parsing.SignatureMissingError,
          parsing.HexStringLengthInvalidError
        ].some((errorClass) => errorClass.is(error)) ? fpTs.either.right(false) : fpTs.either.left(error);
      },
      () => fpTs.either.right(true)
    )
  );
}
function isValid(value, token, options) {
  return betterPromises.BetterPromise.fn(() => {
    return fpTs.function.pipe(
      isValidFp(value, token, options),
      fpTs.taskEither.match((error) => {
        throw error;
      }, (isValid2) => isValid2)
    )();
  });
}
function signFp(data, key, authDate, options) {
  return parsing.signFp(data, key, authDate, signDataFp, options);
}
function sign(data, key, authDate, options) {
  return betterPromises.BetterPromise.fn(() => {
    return fpTs.function.pipe(
      signFp(data, key, authDate, options),
      fpTs.taskEither.match((e) => {
        throw e;
      }, (v) => v)
    )();
  });
}
function signDataFp(data, key, options) {
  return parsing.signDataFp(true, data, key, createHmac, options);
}
function signData(data, key, options) {
  return betterPromises.BetterPromise.fn(() => {
    return fpTs.function.pipe(
      signDataFp(data, key, options),
      fpTs.taskEither.match((e) => {
        throw e;
      }, (v) => v)
    )();
  });
}
function validateFp(value, token, options) {
  return parsing.validateFp(true, value, token, signDataFp, options);
}
function validate(value, token, options) {
  return betterPromises.BetterPromise.fn(async () => {
    await fpTs.function.pipe(
      validateFp(value, token, options),
      fpTs.taskEither.mapLeft((error) => {
        throw error;
      })
    )();
  });
}
exports.AuthDateInvalidError = parsing.AuthDateInvalidError;
exports.ExpiredError = parsing.ExpiredError;
exports.HexStringLengthInvalidError = parsing.HexStringLengthInvalidError;
exports.SignatureInvalidError = parsing.SignatureInvalidError;
exports.SignatureMissingError = parsing.SignatureMissingError;
exports.isValid3rd = parsing.isValid3rd;
exports.isValid3rdFp = parsing.isValid3rdFp;
exports.parse = parsing.parse;
exports.parseFp = parsing.parseFp;
exports.validate3rd = parsing.validate3rd;
exports.validate3rdFp = parsing.validate3rdFp;
Object.defineProperty(exports, "deepSnakeToCamelObjKeys", {
  enumerable: true,
  get: () => toolkit.deepSnakeToCamelObjKeys
});
exports.hashToken = hashToken;
exports.isValid = isValid;
exports.isValidFp = isValidFp;
exports.sign = sign;
exports.signData = signData;
exports.signDataFp = signDataFp;
exports.signFp = signFp;
exports.validate = validate;
exports.validateFp = validateFp;
//# sourceMappingURL=web.cjs.map
