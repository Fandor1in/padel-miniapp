import { either, function as _function, taskEither } from "fp-ts";
import { serializeInitDataQuery, parseInitDataQuery, parseInitDataQueryFp } from "@tma.js/transformers";
import { BetterPromise } from "better-promises";
import { errorClassWithData, errorClass } from "error-kid";
class AuthDateInvalidError extends errorClassWithData(
  "AuthDateInvalidError",
  (value) => ({ value }),
  (value) => [`"auth_date" is invalid: ${value || "value is missing"}`]
) {
}
class SignatureInvalidError extends errorClass("SignatureInvalidError") {
}
class HexStringLengthInvalidError extends errorClass(
  "HexStringLengthInvalidError"
) {
}
class SignatureMissingError extends errorClass(
  "SignatureMissingError",
  (thirdParty) => [`"${thirdParty ? "signature" : "hash"}" parameter is missing`]
) {
}
class ExpiredError extends errorClassWithData(
  "ExpiredError",
  (issuedAt, expiresAt) => ({ issuedAt, expiresAt }),
  (issuedAt, expiresAt, now) => [
    `Init data expired. Issued at ${issuedAt.toISOString()}, expires at ${expiresAt.toISOString()}, now is ${now.toISOString()}`
  ]
) {
}
function hexToArrayBuffer(hexString) {
  if (hexString.length % 2 !== 0) {
    return either.left(new HexStringLengthInvalidError());
  }
  const buffer = new ArrayBuffer(hexString.length / 2);
  const uint8Array = new Uint8Array(buffer);
  for (let i = 0; i < hexString.length; i += 2) {
    uint8Array[i / 2] = parseInt(hexString.substring(i, i + 2), 16);
  }
  return either.right(buffer);
}
function arrayBufferToHex(arrBuf) {
  return new Uint8Array(arrBuf).reduce((acc, byte) => {
    return acc + byte.toString(16).padStart(2, "0");
  }, "");
}
function bufferToArrayBuffer(buf) {
  const ab = new ArrayBuffer(buf.length);
  buf.copy(new Uint8Array(ab));
  return ab;
}
function hashToken(token, createHmac) {
  return createHmac(token, "WebAppData");
}
function signDataFp(async, data, key, createHmac, options = {}) {
  const keyHmac = options.tokenHashed ? typeof key === "string" ? hexToArrayBuffer(key) : either.right(key) : _function.pipe(
    either.right(hashToken(key, createHmac)),
    either.match(() => null, (v) => {
      return v instanceof Promise ? taskEither.tryCatch(() => v, (err) => err) : either.right(v);
    })
  );
  if (async || typeof keyHmac === "function") {
    return _function.pipe(
      typeof keyHmac === "function" ? keyHmac : taskEither.fromEither(keyHmac),
      taskEither.chainW((v) => taskEither.tryCatch(
        () => Promise.resolve(createHmac(data, v)).then(arrayBufferToHex),
        (err) => err
      ))
    );
  }
  return _function.pipe(
    keyHmac,
    // In this branch createHmac can't be asynchronous. If it is, keyHmac would be Promise and the
    // result would be returned in the previous "if" statement.
    either.chain((v) => either.right(
      arrayBufferToHex(createHmac(data, v))
    ))
  );
}
function signFp(data, key, authDate, signData, options) {
  const query = new URLSearchParams(serializeInitDataQuery({
    ...data,
    auth_date: authDate,
    signature: data.signature || ""
  }));
  const pairs = [...query.entries()].map(([name, value]) => `${name}=${value}`).sort();
  const queryWithHash = (signature) => {
    query.append("hash", signature);
    return query.toString();
  };
  const eitherHash = signData(pairs.join("\n"), key, options);
  return typeof eitherHash === "function" ? _function.pipe(eitherHash, taskEither.chain((hash) => taskEither.right(queryWithHash(hash)))) : _function.pipe(eitherHash, either.chain((hash) => either.right(queryWithHash(hash))));
}
function validate3rdFp(value, botId, options = {}) {
  let authDate;
  let authDateString;
  let signature;
  const pairs = [];
  (typeof value === "string" ? new URLSearchParams(value) : value).forEach((value2, key) => {
    if (key === "hash") {
      return;
    }
    if (key === "signature") {
      signature = value2;
      return;
    }
    if (key === "auth_date") {
      authDateString = value2;
      const authDateNum = parseInt(value2, 10);
      if (!Number.isNaN(authDateNum)) {
        authDate = new Date(authDateNum * 1e3);
      }
    }
    pairs.push(`${key}=${value2}`);
  });
  if (!signature) {
    return taskEither.left(new SignatureMissingError(true));
  }
  if (!authDate) {
    return taskEither.left(new AuthDateInvalidError(authDateString));
  }
  const { expiresIn = 86400 } = options;
  if (expiresIn > 0) {
    const expiresAtTs = authDate.getTime() + expiresIn * 1e3;
    const nowTs = Date.now();
    if (expiresAtTs < nowTs) {
      return taskEither.left(new ExpiredError(authDate, new Date(expiresAtTs), new Date(nowTs)));
    }
  }
  return _function.pipe(
    taskEither.tryCatch(
      () => {
        return BetterPromise.fn(async () => {
          return crypto.subtle.verify(
            "Ed25519",
            await crypto.subtle.importKey(
              "raw",
              Buffer.from(
                options.test ? "40055058a4ee38156a06562e52eece92a771bcd8346a8c4615cb7376eddf72ec" : "e7bf03a2fa4602af4580703d88dda5bb59f32ed8b02a56c187fe7d34caed242d",
                "hex"
              ),
              "Ed25519",
              false,
              ["verify"]
            ),
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
            Buffer.from(signature, "base64"),
            Buffer.from(`${botId}:WebAppData
${pairs.sort().join("\n")}`)
          );
        }, options);
      },
      (e) => e
    ),
    taskEither.chainW((isVerified) => {
      return isVerified ? taskEither.right(void 0) : taskEither.left(new SignatureInvalidError());
    })
  );
}
function validate3rd(value, botId, options) {
  return BetterPromise.fn(async () => {
    await _function.pipe(
      validate3rdFp(value, botId, options),
      taskEither.mapLeft((error) => {
        throw error;
      })
    )();
  });
}
function isValid3rdFp(value, botId, options) {
  return _function.pipe(validate3rdFp(value, botId, options), taskEither.match(
    () => either.right(false),
    () => either.right(true)
  ));
}
function isValid3rd(value, botId, options) {
  return BetterPromise.fn(() => _function.pipe(
    isValid3rdFp(value, botId, options),
    taskEither.match(() => false, (v) => v)
  )());
}
function validateFp(async, value, token, signData, options = {}) {
  let authDate;
  let authDateString;
  let hash;
  const pairs = [];
  (typeof value === "string" ? new URLSearchParams(value) : value).forEach((value2, key) => {
    if (key === "hash") {
      hash = value2;
      return;
    }
    if (key === "auth_date") {
      authDateString = value2;
      const authDateNum = parseInt(value2, 10);
      if (!Number.isNaN(authDateNum)) {
        authDate = new Date(authDateNum * 1e3);
      }
    }
    pairs.push(`${key}=${value2}`);
  });
  if (!hash) {
    return (async ? taskEither.left : either.left)(new SignatureMissingError(false));
  }
  if (!authDate) {
    return (async ? taskEither.left : either.left)(new AuthDateInvalidError(authDateString));
  }
  const { expiresIn = 86400 } = options;
  if (expiresIn > 0) {
    const expiresAtTs = authDate.getTime() + expiresIn * 1e3;
    const nowTs = Date.now();
    if (expiresAtTs < nowTs) {
      return (async ? taskEither.left : either.left)(
        new ExpiredError(authDate, new Date(expiresAtTs), new Date(nowTs))
      );
    }
  }
  pairs.sort();
  const eitherSignature = signData(pairs.join("\n"), token, options);
  const onLeft = (error) => either.left(error);
  const onRight = (signature) => signature === hash ? either.right(void 0) : either.left(new SignatureInvalidError());
  return typeof eitherSignature === "function" ? _function.pipe(eitherSignature, taskEither.matchW(onLeft, onRight)) : _function.pipe(eitherSignature, either.matchW(onLeft, onRight));
}
const parse = parseInitDataQuery;
const parseFp = parseInitDataQueryFp;
export {
  AuthDateInvalidError as A,
  ExpiredError as E,
  HexStringLengthInvalidError as H,
  SignatureInvalidError as S,
  signDataFp as a,
  bufferToArrayBuffer as b,
  SignatureMissingError as c,
  parseFp as d,
  isValid3rdFp as e,
  validate3rd as f,
  validate3rdFp as g,
  hashToken as h,
  isValid3rd as i,
  parse as p,
  signFp as s,
  validateFp as v
};
//# sourceMappingURL=parsing-Cjnt3_z4.js.map
