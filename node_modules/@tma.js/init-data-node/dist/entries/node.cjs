"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const fpTs = require("fp-ts");
const node_crypto = require("node:crypto");
const parsing = require("./parsing-4VnIGv0b.cjs");
const toolkit = require("@tma.js/toolkit");
function textToBuffer(text) {
  return Buffer.from(typeof text === "string" ? text : new Uint8Array(text));
}
const createHmac = (data, key) => {
  return parsing.bufferToArrayBuffer(
    node_crypto.createHmac("sha256", textToBuffer(key)).update(textToBuffer(data)).digest()
  );
};
function hashToken(token) {
  return Buffer.from(parsing.hashToken(token, createHmac));
}
function isValid(value, token, options) {
  return fpTs.function.pipe(
    validateFp(value, token, options),
    fpTs.either.match(() => false, () => true)
  );
}
function signFp(data, key, authDate, options) {
  return parsing.signFp(data, key, authDate, signDataFp, options);
}
function sign(data, key, authDate, options) {
  return fpTs.function.pipe(
    signFp(data, key, authDate, options),
    fpTs.either.match((e) => {
      throw e;
    }, (v) => v)
  );
}
function signDataFp(data, key, options) {
  return parsing.signDataFp(false, data, key, createHmac, options);
}
function signData(data, key, options) {
  return fpTs.function.pipe(
    signDataFp(data, key, options),
    fpTs.either.match((e) => {
      throw e;
    }, (v) => v)
  );
}
function validateFp(value, token, options) {
  return parsing.validateFp(false, value, token, signDataFp, options);
}
function validate(value, token, options) {
  fpTs.function.pipe(
    validateFp(value, token, options),
    fpTs.either.mapLeft((error) => {
      throw error;
    })
  );
}
exports.AuthDateInvalidError = parsing.AuthDateInvalidError;
exports.ExpiredError = parsing.ExpiredError;
exports.HexStringLengthInvalidError = parsing.HexStringLengthInvalidError;
exports.SignatureInvalidError = parsing.SignatureInvalidError;
exports.SignatureMissingError = parsing.SignatureMissingError;
exports.isValid3rd = parsing.isValid3rd;
exports.isValid3rdFp = parsing.isValid3rdFp;
exports.parse = parsing.parse;
exports.parseFp = parsing.parseFp;
exports.validate3rd = parsing.validate3rd;
exports.validate3rdFp = parsing.validate3rdFp;
Object.defineProperty(exports, "deepSnakeToCamelObjKeys", {
  enumerable: true,
  get: () => toolkit.deepSnakeToCamelObjKeys
});
exports.hashToken = hashToken;
exports.isValid = isValid;
exports.sign = sign;
exports.signData = signData;
exports.signDataFp = signDataFp;
exports.signFp = signFp;
exports.validate = validate;
exports.validateFp = validateFp;
//# sourceMappingURL=node.cjs.map
