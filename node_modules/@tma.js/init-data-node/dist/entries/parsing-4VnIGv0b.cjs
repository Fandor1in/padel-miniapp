"use strict";
const fpTs = require("fp-ts");
const transformers = require("@tma.js/transformers");
const betterPromises = require("better-promises");
const errorKid = require("error-kid");
class AuthDateInvalidError extends errorKid.errorClassWithData(
  "AuthDateInvalidError",
  (value) => ({ value }),
  (value) => [`"auth_date" is invalid: ${value || "value is missing"}`]
) {
}
class SignatureInvalidError extends errorKid.errorClass("SignatureInvalidError") {
}
class HexStringLengthInvalidError extends errorKid.errorClass(
  "HexStringLengthInvalidError"
) {
}
class SignatureMissingError extends errorKid.errorClass(
  "SignatureMissingError",
  (thirdParty) => [`"${thirdParty ? "signature" : "hash"}" parameter is missing`]
) {
}
class ExpiredError extends errorKid.errorClassWithData(
  "ExpiredError",
  (issuedAt, expiresAt) => ({ issuedAt, expiresAt }),
  (issuedAt, expiresAt, now) => [
    `Init data expired. Issued at ${issuedAt.toISOString()}, expires at ${expiresAt.toISOString()}, now is ${now.toISOString()}`
  ]
) {
}
function hexToArrayBuffer(hexString) {
  if (hexString.length % 2 !== 0) {
    return fpTs.either.left(new HexStringLengthInvalidError());
  }
  const buffer = new ArrayBuffer(hexString.length / 2);
  const uint8Array = new Uint8Array(buffer);
  for (let i = 0; i < hexString.length; i += 2) {
    uint8Array[i / 2] = parseInt(hexString.substring(i, i + 2), 16);
  }
  return fpTs.either.right(buffer);
}
function arrayBufferToHex(arrBuf) {
  return new Uint8Array(arrBuf).reduce((acc, byte) => {
    return acc + byte.toString(16).padStart(2, "0");
  }, "");
}
function bufferToArrayBuffer(buf) {
  const ab = new ArrayBuffer(buf.length);
  buf.copy(new Uint8Array(ab));
  return ab;
}
function hashToken(token, createHmac) {
  return createHmac(token, "WebAppData");
}
function signDataFp(async, data, key, createHmac, options = {}) {
  const keyHmac = options.tokenHashed ? typeof key === "string" ? hexToArrayBuffer(key) : fpTs.either.right(key) : fpTs.function.pipe(
    fpTs.either.right(hashToken(key, createHmac)),
    fpTs.either.match(() => null, (v) => {
      return v instanceof Promise ? fpTs.taskEither.tryCatch(() => v, (err) => err) : fpTs.either.right(v);
    })
  );
  if (async || typeof keyHmac === "function") {
    return fpTs.function.pipe(
      typeof keyHmac === "function" ? keyHmac : fpTs.taskEither.fromEither(keyHmac),
      fpTs.taskEither.chainW((v) => fpTs.taskEither.tryCatch(
        () => Promise.resolve(createHmac(data, v)).then(arrayBufferToHex),
        (err) => err
      ))
    );
  }
  return fpTs.function.pipe(
    keyHmac,
    // In this branch createHmac can't be asynchronous. If it is, keyHmac would be Promise and the
    // result would be returned in the previous "if" statement.
    fpTs.either.chain((v) => fpTs.either.right(
      arrayBufferToHex(createHmac(data, v))
    ))
  );
}
function signFp(data, key, authDate, signData, options) {
  const query = new URLSearchParams(transformers.serializeInitDataQuery({
    ...data,
    auth_date: authDate,
    signature: data.signature || ""
  }));
  const pairs = [...query.entries()].map(([name, value]) => `${name}=${value}`).sort();
  const queryWithHash = (signature) => {
    query.append("hash", signature);
    return query.toString();
  };
  const eitherHash = signData(pairs.join("\n"), key, options);
  return typeof eitherHash === "function" ? fpTs.function.pipe(eitherHash, fpTs.taskEither.chain((hash) => fpTs.taskEither.right(queryWithHash(hash)))) : fpTs.function.pipe(eitherHash, fpTs.either.chain((hash) => fpTs.either.right(queryWithHash(hash))));
}
function validate3rdFp(value, botId, options = {}) {
  let authDate;
  let authDateString;
  let signature;
  const pairs = [];
  (typeof value === "string" ? new URLSearchParams(value) : value).forEach((value2, key) => {
    if (key === "hash") {
      return;
    }
    if (key === "signature") {
      signature = value2;
      return;
    }
    if (key === "auth_date") {
      authDateString = value2;
      const authDateNum = parseInt(value2, 10);
      if (!Number.isNaN(authDateNum)) {
        authDate = new Date(authDateNum * 1e3);
      }
    }
    pairs.push(`${key}=${value2}`);
  });
  if (!signature) {
    return fpTs.taskEither.left(new SignatureMissingError(true));
  }
  if (!authDate) {
    return fpTs.taskEither.left(new AuthDateInvalidError(authDateString));
  }
  const { expiresIn = 86400 } = options;
  if (expiresIn > 0) {
    const expiresAtTs = authDate.getTime() + expiresIn * 1e3;
    const nowTs = Date.now();
    if (expiresAtTs < nowTs) {
      return fpTs.taskEither.left(new ExpiredError(authDate, new Date(expiresAtTs), new Date(nowTs)));
    }
  }
  return fpTs.function.pipe(
    fpTs.taskEither.tryCatch(
      () => {
        return betterPromises.BetterPromise.fn(async () => {
          return crypto.subtle.verify(
            "Ed25519",
            await crypto.subtle.importKey(
              "raw",
              Buffer.from(
                options.test ? "40055058a4ee38156a06562e52eece92a771bcd8346a8c4615cb7376eddf72ec" : "e7bf03a2fa4602af4580703d88dda5bb59f32ed8b02a56c187fe7d34caed242d",
                "hex"
              ),
              "Ed25519",
              false,
              ["verify"]
            ),
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
            Buffer.from(signature, "base64"),
            Buffer.from(`${botId}:WebAppData
${pairs.sort().join("\n")}`)
          );
        }, options);
      },
      (e) => e
    ),
    fpTs.taskEither.chainW((isVerified) => {
      return isVerified ? fpTs.taskEither.right(void 0) : fpTs.taskEither.left(new SignatureInvalidError());
    })
  );
}
function validate3rd(value, botId, options) {
  return betterPromises.BetterPromise.fn(async () => {
    await fpTs.function.pipe(
      validate3rdFp(value, botId, options),
      fpTs.taskEither.mapLeft((error) => {
        throw error;
      })
    )();
  });
}
function isValid3rdFp(value, botId, options) {
  return fpTs.function.pipe(validate3rdFp(value, botId, options), fpTs.taskEither.match(
    () => fpTs.either.right(false),
    () => fpTs.either.right(true)
  ));
}
function isValid3rd(value, botId, options) {
  return betterPromises.BetterPromise.fn(() => fpTs.function.pipe(
    isValid3rdFp(value, botId, options),
    fpTs.taskEither.match(() => false, (v) => v)
  )());
}
function validateFp(async, value, token, signData, options = {}) {
  let authDate;
  let authDateString;
  let hash;
  const pairs = [];
  (typeof value === "string" ? new URLSearchParams(value) : value).forEach((value2, key) => {
    if (key === "hash") {
      hash = value2;
      return;
    }
    if (key === "auth_date") {
      authDateString = value2;
      const authDateNum = parseInt(value2, 10);
      if (!Number.isNaN(authDateNum)) {
        authDate = new Date(authDateNum * 1e3);
      }
    }
    pairs.push(`${key}=${value2}`);
  });
  if (!hash) {
    return (async ? fpTs.taskEither.left : fpTs.either.left)(new SignatureMissingError(false));
  }
  if (!authDate) {
    return (async ? fpTs.taskEither.left : fpTs.either.left)(new AuthDateInvalidError(authDateString));
  }
  const { expiresIn = 86400 } = options;
  if (expiresIn > 0) {
    const expiresAtTs = authDate.getTime() + expiresIn * 1e3;
    const nowTs = Date.now();
    if (expiresAtTs < nowTs) {
      return (async ? fpTs.taskEither.left : fpTs.either.left)(
        new ExpiredError(authDate, new Date(expiresAtTs), new Date(nowTs))
      );
    }
  }
  pairs.sort();
  const eitherSignature = signData(pairs.join("\n"), token, options);
  const onLeft = (error) => fpTs.either.left(error);
  const onRight = (signature) => signature === hash ? fpTs.either.right(void 0) : fpTs.either.left(new SignatureInvalidError());
  return typeof eitherSignature === "function" ? fpTs.function.pipe(eitherSignature, fpTs.taskEither.matchW(onLeft, onRight)) : fpTs.function.pipe(eitherSignature, fpTs.either.matchW(onLeft, onRight));
}
const parse = transformers.parseInitDataQuery;
const parseFp = transformers.parseInitDataQueryFp;
exports.AuthDateInvalidError = AuthDateInvalidError;
exports.ExpiredError = ExpiredError;
exports.HexStringLengthInvalidError = HexStringLengthInvalidError;
exports.SignatureInvalidError = SignatureInvalidError;
exports.SignatureMissingError = SignatureMissingError;
exports.bufferToArrayBuffer = bufferToArrayBuffer;
exports.hashToken = hashToken;
exports.isValid3rd = isValid3rd;
exports.isValid3rdFp = isValid3rdFp;
exports.parse = parse;
exports.parseFp = parseFp;
exports.signDataFp = signDataFp;
exports.signFp = signFp;
exports.validate3rd = validate3rd;
exports.validate3rdFp = validate3rdFp;
exports.validateFp = validateFp;
//# sourceMappingURL=parsing-4VnIGv0b.cjs.map
